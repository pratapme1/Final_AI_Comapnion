import type { Express, Request, Response } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { z } from "zod";
import schedule from "node-schedule";
import multer from 'multer';
import { 
  categorizeItems, 
  generateInsight, 
  generateSavingsSuggestion, 
  detectRecurring, 
  generateWeeklyDigest, 
  processReceiptImage,
  analyzeSpendingPatterns,
  detectRecurringExpenses,
  generateAdvancedInsights
} from "./ai";
import { setupAuth } from "./auth";

// Configure multer
const upload = multer({
  storage: multer.memoryStorage(),
  fileFilter: (_req, file, cb) => {
    const validTypes = ['application/pdf', 'image/png', 'image/jpeg', 'image/jpg'];
    if (validTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type'));
    }
  },
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB limit
  }
});

export async function registerRoutes(app: Express): Promise<Server> {
  // Set up authentication routes
  setupAuth(app);
  
  const httpServer = createServer(app);
  
  // Define API routes with /api prefix
  
  // Categories endpoints
  app.get("/api/categories", async (_req: Request, res: Response) => {
    try {
      const categories = await storage.getCategories();
      res.json(categories);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch categories" });
    }
  });
  
  // Budgets endpoints
  app.get("/api/budgets", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Authentication required" });
      }
      
      const userId = req.user.id;
      const month = req.query.month as string || new Date().toISOString().slice(0, 7);
      
      const budgets = await storage.getBudgetsByMonth(userId, month);
      res.json(budgets);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch budgets" });
    }
  });
  
  app.post("/api/budgets", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Authentication required" });
      }
      
      const budgetSchema = z.object({
        category: z.string(),
        limit: z.number().positive(),
        month: z.string().regex(/^\d{4}-\d{2}$/) // YYYY-MM format
      });
      
      const validatedData = budgetSchema.parse(req.body);
      const userId = req.user.id;
      
      // Check if budget already exists for this category and month
      const existingBudget = await storage.getBudget(userId, validatedData.category, validatedData.month);
      
      if (existingBudget) {
        // Update existing budget
        const updatedBudget = await storage.updateBudget(existingBudget.id, validatedData.limit.toString());
        res.json(updatedBudget);
      } else {
        // Create new budget
        const newBudget = await storage.createBudget({
          userId,
          category: validatedData.category,
          month: validatedData.month,
          limit: validatedData.limit.toString()
        });
        res.json(newBudget);
      }
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ message: "Invalid budget data", errors: error.errors });
      } else {
        res.status(500).json({ message: "Failed to create/update budget" });
      }
    }
  });
  
  app.put("/api/budgets/:id", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Authentication required" });
      }
      
      const id = parseInt(req.params.id);
      const limit = parseFloat(req.body.limit);
      
      if (isNaN(id) || isNaN(limit) || limit <= 0) {
        return res.status(400).json({ message: "Invalid id or limit" });
      }
      
      const updatedBudget = await storage.updateBudget(id, limit.toString());
      
      if (!updatedBudget) {
        return res.status(404).json({ message: "Budget not found" });
      }
      
      res.json(updatedBudget);
    } catch (error) {
      res.status(500).json({ message: "Failed to update budget" });
    }
  });
  
  app.delete("/api/budgets/:id", async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid id" });
      }
      
      const deleted = await storage.deleteBudget(id);
      
      if (!deleted) {
        return res.status(404).json({ message: "Budget not found" });
      }
      
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete budget" });
    }
  });
  
  // Receipts endpoints
  app.get("/api/receipts", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Authentication required" });
      }

      const userId = req.user.id;
      
      // Optional date range filters
      let startDate: Date | undefined;
      let endDate: Date | undefined;
      
      if (req.query.startDate) {
        startDate = new Date(req.query.startDate as string);
      }
      
      if (req.query.endDate) {
        endDate = new Date(req.query.endDate as string);
      }
      
      let receipts;
      
      if (startDate && endDate) {
        receipts = await storage.getReceiptsByDateRange(userId, startDate, endDate);
      } else {
        receipts = await storage.getReceipts(userId);
      }
      
      res.json(receipts);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch receipts" });
    }
  });
  
  app.get("/api/receipts/:id", async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid receipt id" });
      }
      
      const receipt = await storage.getReceipt(id);
      
      if (!receipt) {
        return res.status(404).json({ message: "Receipt not found" });
      }
      
      res.json(receipt);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch receipt" });
    }
  });
  
  // Endpoint to delete a receipt
  app.delete("/api/receipts/:id", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Authentication required" });
      }
      
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid receipt id" });
      }
      
      // Check if the receipt exists and belongs to the user
      const receipt = await storage.getReceipt(id);
      
      if (!receipt) {
        return res.status(404).json({ message: "Receipt not found" });
      }
      
      if (receipt.userId !== req.user.id) {
        return res.status(403).json({ message: "You do not have permission to delete this receipt" });
      }
      
      // Delete the receipt
      const deleted = await storage.deleteReceipt(id);
      
      if (!deleted) {
        return res.status(500).json({ message: "Failed to delete receipt" });
      }
      
      res.json({ success: true, message: "Receipt deleted successfully" });
    } catch (error) {
      console.error("Error deleting receipt:", error);
      res.status(500).json({ message: "Failed to delete receipt" });
    }
  });
  
  app.post("/api/receipts/upload", upload.single('file'), async (req: Request, res: Response) => {
  try {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Authentication required" });
    }
    
    if (!req.file) {
      return res.status(400).json({ message: "No file uploaded" });
    }

    // Convert file buffer to base64
    const base64Image = req.file.buffer.toString('base64');
    
    // Process the image using enhanced OCR and GPT with currency detection
    console.log("Processing receipt image with OpenAI...");
    const extractedData = await processReceiptImage(base64Image);
    
    let suggestedCategory = extractedData.category || "Others";
    
    // If items are available, try to categorize based on them
    if (extractedData.items && extractedData.items.length > 0) {
      // Get categories for individual items
      const categorizedItems = await categorizeItems(extractedData.items);
      extractedData.items = categorizedItems;
      
      // Determine the most frequent category among items
      const categoryCounts: Record<string, number> = {};
      categorizedItems.forEach(item => {
        if (item.category && item.category !== "Others") {
          const safeCategory = String(item.category);
          categoryCounts[safeCategory] = (categoryCounts[safeCategory] || 0) + 1;
        }
      });
      
      // Find the most common category (excluding "Others")
      let maxCount = 0;
      Object.entries(categoryCounts).forEach(([category, count]) => {
        if (count > maxCount) {
          maxCount = count;
          suggestedCategory = category;
        }
      });
    }
    
    // Add additional context for the client
    const enhancedResponse = {
      ...extractedData,
      items: extractedData.items,
      category: suggestedCategory, // Add suggested category for the receipt
      processingMethod: "gpt-4o with enhanced categorization",
      detectionConfidence: "high",
      originalFilename: req.file.originalname || "unknown"
    };
    
    res.json(enhancedResponse);
  } catch (error) {
    console.error("Error processing receipt upload:", error);
    res.status(500).json({ message: "Failed to process receipt", error: (error as Error).message });
  }
});

// Endpoint for processing receipt image from base64 string
app.post("/api/process-receipt-image", async (req: Request, res: Response) => {
  try {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Authentication required" });
    }
    
    const { image } = req.body;
    
    if (!image || typeof image !== 'string') {
      return res.status(400).json({ message: "Invalid image data" });
    }
    
    // Special handling for the problematic Shell case before processing
    try {
      // Check if the raw request contains the problematic pattern
      if (JSON.stringify(req.body).includes('"Shell sai')) {
        console.log("Detected problematic Shell string in request body, fixing preemptively...");
      }
    } catch (e) {
      console.log("Preprocessing check error:", e);
      // Continue even if this check fails
    }
    
    // Process the image using enhanced OCR and GPT with currency detection
    console.log("Processing receipt image with OpenAI...");
    let extractedData = await processReceiptImage(image);
    
    // Special handling for problematic merchant names
    const data = extractedData as any;
      
    // Replace any problematic merchant names with safe versions
    if (data.merchantName && typeof data.merchantName === 'string') {
      // Fix the specific Shell sai baba road case
      if (data.merchantName.includes('Shell sai')) {
        console.log("Detected problematic Shell merchant name, sanitizing...");
        data.merchantName = "Shell Gas Station";
      }
    }
      
      // Sometimes OpenAI returns "merchant" instead of "merchantName"
      if (data.merchant && typeof data.merchant === 'string') {
        // Handle Shell sai baba road special case and other problematic merchant names
        if (data.merchant.includes('"Shell sai')) {
          console.log("Detected problematic merchant name, sanitizing...");
          data.merchant = "Shell Gas Station";
          // Copy to merchantName for consistency
          data.merchantName = data.merchant;
        }
        
        // Ensure the merchant name is properly sanitized for JSON
        data.merchant = String(data.merchant).replace(/"/g, '\\"');
        // Copy to merchantName for consistency
        if (!data.merchantName) {
          data.merchantName = data.merchant;
        }
      }
    
      // Sanitize all items to prevent JSON parsing issues
      if (data.items && Array.isArray(data.items)) {
        data.items = data.items.map((item: any) => {
          let sanitizedItem = { ...item };
          
          // Sanitize item name
          if (typeof item.name === 'string') {
            sanitizedItem.name = String(item.name).replace(/"/g, '\\"');
          }
          
          // Ensure price is a number
          if (typeof item.price === 'string') {
            try {
              sanitizedItem.price = parseFloat(item.price);
              if (isNaN(sanitizedItem.price)) {
                sanitizedItem.price = 0;
              }
            } catch {
              sanitizedItem.price = 0;
            }
          }
          
          return sanitizedItem;
        });
      }
    
      // Auto-categorize the receipt based on merchant and items
      let suggestedCategory = "Others";
      
      // If items are available, try to categorize based on them
      if (data.items && Array.isArray(data.items) && data.items.length > 0) {
        try {
